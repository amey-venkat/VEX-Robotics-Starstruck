#pragma config(Sensor, in1,    potClaw,        sensorPotentiometer)
#pragma config(Sensor, in2,    potArm,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  quadLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quadRight,      sensorQuadEncoder)
#pragma config(Motor,  port1,           frontLeft,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LiftArmLeftA,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LiftArmLeftB,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           LiftArmRightA, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LiftArmRightB, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          frontRight,    tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition) //Competition Control Settings
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
/***********************************************************************************************
Team: RoboWarriors	98872 R
************************************************************************************************/
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

// Include the lcd button get utility function
#include "getlcdbuttons.c"

// global hold the auton selection
int MyAutonomous = 0;
int iPage = 0; // Page 0 = shows 0&1, Page 1 = shows 2&3

// Global variables
int iLeftEncValue = 0;
int iRightEncValue = 0;
int iPotArm = 0;
int iPotClaw = 0;

/************************************************************************************************/
/*  Function Prototypes   								                                                      */
/************************************************************************************************/
void LcdSetAutonomous( int value );
void LcdAutonomousSelection();
void autonLeft();
void autonRight();
void autonSimpleLeft();
void autonSimpleRight();
void ResetQuadEncoder();
void MoveRobot(int speed);
void StopRobot();
void SpinRobot(int leftSpeed);
void ResetPotArm();
void MoveArm(int power);
void HoldArm();
void StopArm();
void OpenClaw(int power);
void StopClaw();
void BombsAway();
void Defence();


/************************************************************************************************/
/*  pre_auton : Setup LCD display for picking correct Auton program   	                        */
/************************************************************************************************/
void pre_auton()
{
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	LcdAutonomousSelection();
}

/************************************************************************************************/
/*  autonomous : Called by competition switch											    	                        */
/************************************************************************************************/
task autonomous()
{
	switch( MyAutonomous ) {
	case    0:
		autonLeft();
		break;

	case    1:
		autonRight();
		break;

	case    2:
		autonSimpleLeft();
		break;

	case    3:
		autonSimpleRight();
		break;

	default:
		//autonSimpleLeft();
		break;
	}
}

/************************************************************************************************/
/*  usercontrol : Driver control             											    	                        */
/************************************************************************************************/
task usercontrol()
{
	int liftArmPowerUp = 95;
	int liftArmPowerDown = -50;
	int liftArmPowerHold = 0;
	int clawPower = 80;
	int X1 = 0, Y3 = 0, threshold = 25;

	ResetQuadEncoder();
	ResetPotArm();

	while (true)
	{

		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold)
			Y3 = vexRT[Ch3];
		else
			Y3 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold)
			X1 = vexRT[Ch1];
		else
			X1 = 0;

		//Remote Control Commands
		motor[frontRight] = Y3 - X1;
		motor[backRight] 	= Y3 - X1;
		motor[frontLeft] 	= Y3 + X1;
		motor[backLeft] 	= Y3 + X1;

		// Bombs away
		if (vexRT[Btn8U]==1)
		{
			BombsAway();
		}
		// Defence
		if (vexRT[Btn7U]==1)
		{
			Defence();
		}
		if (vexRT[Btn6D]==1)
		{
			MoveArm(liftArmPowerDown);
		}
		else if (vexRT[Btn6U]==1)
		{
			MoveArm(liftArmPowerUp);
		}
		else
		{
			MoveArm(liftArmPowerHold);
		}
		if (vexRT[Btn5U]==1)
		{
			OpenClaw(clawPower);
		}
		else if (vexRT[Btn5D]==1)
		{
			OpenClaw(-clawPower);
		}
		else
		{
			//motor[Claw]=5;
			OpenClaw(5);
		}

		iLeftEncValue = SensorValue[quadLeft];
		iRightEncValue = SensorValue[quadRight];

		clearLCDLine(0);//Clears the LCD Display
		clearLCDLine(1);

		setLCDPosition(0,0); //Sets the VEX cursor on the first line
		displayNextLCDString("L: ");
		displayNextLCDNumber(SensorValue(quadLeft));//Displays the value of left encoder
		displayNextLCDString(" R: ");
		displayNextLCDNumber(SensorValue(quadRight));//Displays the value of left encoder

		setLCDPosition(1,0); //Sets the VEX Cursor on the second line
		displayNextLCDString("A: ");
		displayNextLCDNumber(SensorValue(potArm));//Displays value of arm pot
		displayNextLCDString(" C: ");
		displayNextLCDNumber(SensorValue(potClaw));//Displays value of claw pot

	}
}

/************************************************************************************************/
/*  Display autonomous selection                      						    	                        */
/************************************************************************************************/
void LcdSetAutonomous( int value )
{
	switch (iPage)
	{
	case 0:
		// Page 0
		if( value == 0 ) {
			displayLCDString(0, 0, "AL ");
			displayLCDString(1, 0, "[00]   01    >> ");
		}
		if( value == 1 ) {
			displayLCDString(0, 0, "AR ");
			displayLCDString(1, 0, " 00   [01]   >> ");
		}
		break;

	case 1:
		// Page 1
		if( value == 2 ) {
			displayLCDString(0, 0, "SAL");
			displayLCDString(1, 0, "[02]   03    >> ");
		}
		if( value == 3 ) {
			displayLCDString(0, 0, "SAR");
			displayLCDString(1, 0, " 02   [03]   >> ");
		}
		break;

	default:
	}

	// Save autonomous mode for later
	MyAutonomous = value;
}

/************************************************************************************************/
/*  Autonomous Left side                              						    	                        */
/************************************************************************************************/
void autonLeft()
{
	ResetQuadEncoder();
	ResetPotArm();

	OpenClaw(80);
	wait1Msec(200);
	StopClaw();

	// go towards the fence
	MoveRobot(-100);
	while (iLeftEncValue >= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	OpenClaw(50);
	wait1Msec(650);
	StopClaw();

	MoveArm(80);
	wait1Msec(1400);
	HoldArm();

	MoveRobot(-80);
	wait1Msec(600);
	StopRobot();

	MoveArm(-60);
	wait1Msec(100);
	StopArm();

	MoveRobot(80);
	while (iLeftEncValue <= -850)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	// forward to the midline


	wait1Msec(200);
	// turn to the center cube
	ResetQuadEncoder();
	SpinRobot(-60);
	wait1Msec(580);
	StopRobot();

	// drop arm
	MoveArm(-80);
	wait1Msec(1100);
	StopArm();

	// go to cube
	MoveRobot(80);
	while (iLeftEncValue <= 350)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	//catch 2 stars
	OpenClaw(80);
	wait1Msec(1400);
	OpenClaw(15);

	ResetPotArm();
	MoveArm(80);
	iPotArm = SensorValue[potArm];
	while (abs(iPotArm) <= 800)
	{
		iPotArm = SensorValue[potArm];
	}
	HoldArm();

	wait1Msec(100);

	// spin to face back wall
	ResetQuadEncoder();
	SpinRobot(50);
	iLeftEncValue = SensorValue[quadLeft];
	while (iLeftEncValue <= 200)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	// reverse back to middle tile
	MoveRobot(-60);
	wait1Msec(1400);
	StopRobot();

	BombsAway();
	StopRobot();
	StopArm();
	StopClaw();
}
/************************************************************************************************/
/*  Autonomous Right side                             						    	                        */
/************************************************************************************************/
void autonRight()
{
	ResetQuadEncoder();
	ResetPotArm();

	OpenClaw(80);
	wait1Msec(200);
	StopClaw();

	// go towards the fence
	MoveRobot(-100);
	while (iLeftEncValue >= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	OpenClaw(50);
	wait1Msec(650);
	StopClaw();

	MoveArm(80);
	wait1Msec(1400);
	HoldArm();

	MoveRobot(-80);
	wait1Msec(600);
	StopRobot();

	MoveArm(-60);
	wait1Msec(100);
	StopArm();

	MoveRobot(80);
	while (iLeftEncValue <= -850)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	// forward to the midline


	wait1Msec(200);
	// turn to the center cube
	ResetQuadEncoder();
	SpinRobot(60);
	wait1Msec(580);
	StopRobot();


	// drop arm
	MoveArm(-80);
	wait1Msec(1100);
	StopArm();

	// go to cube
	MoveRobot(80);
	wait1Msec(500);
	StopRobot();

	//catch 2 stars
	OpenClaw(80);
	wait1Msec(1400);
	OpenClaw(15);

	ResetPotArm();
	MoveArm(80);
	iPotArm = SensorValue[potArm];
	while (abs(iPotArm) <=800)
	{
		iPotArm = SensorValue[potArm];
	}
	HoldArm();

	wait1Msec(100);


	// spin to face back wall
	ResetQuadEncoder();
	SpinRobot(-60);
	iLeftEncValue = SensorValue[quadLeft];
	while (iLeftEncValue >= -100)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	wait1Msec(300);

	// reverse back to middle tile
	MoveRobot(-60);
	wait1Msec(800);
	StopRobot();

	BombsAway();
	StopRobot();
	StopArm();
	StopClaw();
}

/************************************************************************************************/
/*  Autonomous Simple Left                                						    	                        */
/************************************************************************************************/
void autonSimpleLeft()
{
	ResetQuadEncoder();
	ResetPotArm();

	OpenClaw(80);
	wait1Msec(200);
	StopClaw();

	// go towards the fence
	MoveRobot(-100);
	while (iLeftEncValue >= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	OpenClaw(50);
	wait1Msec(650);
	StopClaw();

	MoveArm(80);
	wait1Msec(1400);
	HoldArm();

	MoveRobot(-80);
	wait1Msec(500);
	StopRobot();

	MoveArm(-60);
	wait1Msec(100);
	StopArm();

	MoveRobot(80);
	while (iLeftEncValue <= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	MoveArm(-80);
	wait1Msec(1400);
	StopArm();

	OpenClaw(50);
	wait1Msec(1700);
	OpenClaw(20);

	MoveRobot(-80);
	wait1Msec(1300);
	StopRobot();

	BombsAway();
	StopArm();
	StopClaw();
	StopRobot();

}

/************************************************************************************************/
/*  Autonomous Simple Right                            						    	                        */
/************************************************************************************************/
void autonSimpleRight()
{
	ResetQuadEncoder();
	ResetPotArm();

	OpenClaw(80);
	wait1Msec(200);
	StopClaw();

	// go towards the fence
	MoveRobot(-100);
	while (iLeftEncValue >= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	OpenClaw(50);
	wait1Msec(650);
	StopClaw();

	MoveArm(80);
	wait1Msec(1400);
	HoldArm();

	MoveRobot(-80);
	wait1Msec(500);
	StopRobot();

	MoveArm(-60);
	wait1Msec(100);
	StopArm();

	MoveRobot(80);
	while (iLeftEncValue <= -900)
	{
		iLeftEncValue = SensorValue[quadLeft];
	}
	StopRobot();

	MoveArm(-80);
	wait1Msec(1400);
	StopArm();

	OpenClaw(50);
	wait1Msec(1700);
	OpenClaw(20);

	MoveRobot(-80);
	wait1Msec(1300);
	StopRobot();

	BombsAway();
	StopArm();
	StopClaw();
	StopRobot();
}
/************************************************************************************************/
/* Drop elements automatically                        						    	                        */
/************************************************************************************************/
void BombsAway()
{

	StopRobot(); // stop robot from moving
	iPotArm = SensorValue[potArm];
	OpenClaw(25);
	MoveArm(125);
	while (abs(iPotArm) <= 2150)
	{
		iPotArm = SensorValue[potArm];
	}
	HoldArm();
	OpenClaw(-100);
	wait1Msec(500);
	OpenClaw(50);
	wait1Msec(150);

	// bring arm down to help with next user round
	MoveArm(-80);
	wait1Msec(1000);
	StopArm();

}

/************************************************************************************************/
/* Defence posture						                        						    	                        */
/************************************************************************************************/
void Defence()
{
	// lift arm
	MoveArm(80);
	iPotArm = SensorValue[potArm];
	while (abs(iPotArm) <= 750)
	{
		iPotArm = SensorValue[potArm];
	}
	HoldArm();
	//open claw to T
	OpenClaw(50);
	iPotClaw = SensorValue[potClaw];
	while (abs(iPotClaw) < 900)
	{
		iPotClaw = SensorValue[potClaw];
	}
	StopClaw();
}

/************************************************************************************************/
/*  Resets the values of the quadrature shaft encoders						    	                        */
/************************************************************************************************/
void ResetQuadEncoder ()
{
	iLeftEncValue = 0;
	iRightEncValue = 0;
	SensorValue[quadRight] = 0;
	SensorValue[quadLeft] = 0;
}

/************************************************************************************************/
/*  Resets the values of the Arm potentiometer						    	                        */
/************************************************************************************************/
void ResetPotArm ()
{
	iPotArm = 0;
	SensorValue[potArm] = 0;
}

/************************************************************************************************/
/*  Select one of three autonomous choices            						    	                        */
/************************************************************************************************/
void LcdAutonomousSelection()
{
	TControllerButtons  button;

	// Clear LCD and turn on backlight
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;

	// diaplay default choice
	LcdSetAutonomous(MyAutonomous); //0

	while( bIfiRobotDisabled )
	{
		// this function blocks until button is pressed
		button = getLcdButtons();

		switch (iPage)
		{
		case 0: // Page 0
			if( button == kButtonLeft )
				LcdSetAutonomous(0);

			if( button == kButtonCenter )
				LcdSetAutonomous(1);

			if( button == kButtonRight ) {
				iPage = 1; // go to page 1
				LcdSetAutonomous(2);
			}
			// Don't hog the cpu !
			wait1Msec(10);
			break;

		case 1: // Page 1
			if( button == kButtonLeft )
				LcdSetAutonomous(2);

			if( button == kButtonCenter )
				LcdSetAutonomous(3);

			if( button == kButtonRight ) {
				iPage = 0; //go to page 0
				LcdSetAutonomous(0);
			}
			// Don't hog the cpu !
			wait1Msec(10);
			break;

		default:
		}

	}
}

/************************************************************************************************/
/*  MoveRobot                                         						    	                        */
/************************************************************************************************/
void MoveRobot(int speed)
{
	motor[backLeft] = speed;
	motor[backRight] = speed;
	motor[frontLeft] = speed;
	motor[frontRight] = speed;
}
/************************************************************************************************/
/*  StopRobot                                         						    	                        */
/************************************************************************************************/
void StopRobot()
{
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
}
/************************************************************************************************/
/*  SpinRobot                                         						    	                        */
/************************************************************************************************/
void SpinRobot(int leftSpeed)
{
	motor[frontLeft] = leftSpeed;
	motor[backLeft] =  leftSpeed;
	motor[frontRight] = -leftSpeed;
	motor[backRight] = -leftSpeed;
}
/************************************************************************************************/
/*  MoveArm                                         						    	                        */
/************************************************************************************************/
void MoveArm(int power)
{
	motor[LiftArmLeftA] = power;
	motor[LiftArmLeftB] = power;
	motor[LiftArmRightA] = power;
	motor[LiftArmRightB] = power;
}
/************************************************************************************************/
/*  HoldArm                                         						    	                        */
/************************************************************************************************/
void HoldArm()
{
	int restingPower = 10;
	motor[LiftArmLeftA] = restingPower;
	motor[LiftArmLeftB] = restingPower;
	motor[LiftArmRightA] = restingPower;
	motor[LiftArmRightB] = restingPower;
	//motor[liftArmMiddle] = restingPower;
}
/************************************************************************************************/
/*  StopArm                                         						    	                        */
/************************************************************************************************/
void StopArm()
{
	motor[LiftArmLeftA] = 0;
	motor[LiftArmLeftB] = 0;
	motor[LiftArmRightA] = 0;
	motor[LiftArmRightB] = 0;
}
/************************************************************************************************/
/*  OpenClaw                                         						    	                        */
/************************************************************************************************/
void OpenClaw(int power)
{
	motor[Claw] = power;
}
/************************************************************************************************/
/*  CloseClaw                                         						    	                        */
/************************************************************************************************/
void StopClaw()
{
	motor[Claw] = 0;
}
/***********************************************************************************************
Team: RoboWarriors	98872 R
__________      ___.              __      __                     .__
\______   \ ____\_ |__   ____    /  \    /  \_____ ______________|__| ___________  ______
|       _//  _ \| __ \ /  _ \   \   \/\/   /\__  \\_  __ \_  __ \  |/  _ \_  __ \/  ___/
|    |   (  <_> ) \_\ (  <_> )   \        /  / __ \|  | \/|  | \/  (  <_> )  | \/\___ \
|____|_  /\____/|___  /\____/     \__/\  /  (____  /__|   |__|  |__|\____/|__|  /____  >
\/           \/                 \/        \/                                  \/
________    ______     ______   _________  ________   __________
/   __   \  /  __  \   /  __  \  \______  \ \_____  \  \______   \
\____    /  >      <   >      <      /    /  /  ____/   |       _/
/    /  /   --   \ /   --   \    /    /  /       \   |    |   \
/____/    \______  / \______  /   /____/   \_______ \  |____|_  /
\/         \/                     \/         \/

____            _                __        __                        _
|  _ \    ___   | |__     ___     \ \      / /   __ _   _ __   _ __  (_)   ___    _ __   ___
| |_) |  / _ \  | '_ \   / _ \     \ \ /\ / /   / _` | | '__| | '__| | |  / _ \  | '__| / __|
|  _ <  | (_) | | |_) | | (_) |     \ V  V /   | (_| | | |    | |    | | | (_) | | |    \__ \
|_| \_\  \___/  |_.__/   \___/       \_/\_/     \__,_| |_|    |_|    |_|  \___/  |_|    |___/

___     ___     ___    _____   ____      ____
/ _ \   ( _ )   ( _ )  |___  | |___ \    |  _ \
|(_) |  / _ \   / _ \     / /    __) |   | |_) |
\__, | | (_) | | (_) |   / /    / __/    |  _ <
/_/   \___/   \___/   /_/    |_____|   |_| \_\

************************************************************************************************/
